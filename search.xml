<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<p>“如切如磋，如琢如磨。”                                                                                                   </p>
<p>                                                                                                                                            ——题记</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“闲来无事不从容，睡觉东窗日已红。”终于盼来了闲暇时光，笔者打算重新整理一下对计算思维的理解。笔者选择的参考书是吴军博士的《计算之魂》，这次算是第三遍学习这本书。第一遍是在《计算之魂》新书发售时，就着新鲜感看完的，只能算观其大略。第二遍是在去年寒假前找实习时，再读一遍，对计算思维有了些许心得，在面试过程中虽然代码写得笨拙但思路基本正确。我认为这本书是很值得反复品味的，里边不仅有对计算思维的解读，还有吴军博士在其工作生涯中的心得体会，常读而常新也。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这篇文章的目的是基于书中<strong>例题1.3 总和最大区间问题</strong>，来剖析算法优化的方向和如何设计出一个好的算法。</p>
<blockquote>
<p>本文所用到的完整代码可访问笔者仓库获取：<a href="https://github.com/haom-liu/Algorithm">https://github.com/haom-liu/Algorithm</a></p>
</blockquote>
<h3 id="算法优化的方法"><a href="#算法优化的方法" class="headerlink" title="算法优化的方法"></a>算法优化的方法</h3><p>算法优化最常用的方法是<strong>找出计算中的无用功</strong>。以本题为例，本文列举出书中给出的四种算法，其复杂度分别为$O(N^3)$、$O(N^2)$、$O(N\log N)$、$O(N)$。笔者将逐层分析算法中的无用功，保持思维上的连贯性，给出非$O(N)$复杂度的算法如何优化到$O(N)$。在本文的附录中，笔者会分析书中复杂度为$O(N\log N)$算法的无用功，并给出优化方法。笔者在本文进行了较多的数学分析，希望帮助读者理解。</p>
<blockquote>
<p><strong>题目描述：</strong></p>
<p>给定一个实数序列，设计一个最有效的算法，找到一个总和最大的区间。</p>
</blockquote>
<p>例如给定序列：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.5</td>
<td align="center">-12.3</td>
<td align="center">3.2</td>
<td align="center">-5.5</td>
<td align="center">23.2</td>
<td align="center">3.2</td>
<td align="center">-1.4</td>
</tr>
<tr>
<td align="center"><strong>7</strong></td>
<td align="center"><strong>8</strong></td>
<td align="center"><strong>9</strong></td>
<td align="center"><strong>10</strong></td>
<td align="center"><strong>11</strong></td>
<td align="center"><strong>12</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-12.2</td>
<td align="center">34.2</td>
<td align="center">5.4</td>
<td align="center">-7.8</td>
<td align="center">1.1</td>
<td align="center">-4.9</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>其中总和最大区间为$[4, 9]$。</p>
<p>接下来按照复杂度从高到低依次介绍各种可行的算法，并分析算法中可以优化的步骤。</p>
<h3 id="O-N-3-算法"><a href="#O-N-3-算法" class="headerlink" title="$O(N^3)$算法"></a>$O(N^3)$算法</h3><p>这种方法是做三重循环，需要三个指针$i$、$j$、$k$，其中$i$指向区间左端点，$j$指向区间右端点，$k$用于从左端点到右端点进行遍历求和。因此最好和最坏情况下，该算法的时间复杂度都是$O(N^3)$。</p>
<p>C++实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">op1</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">float</span>&gt;&amp; input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> maxx = input[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; input.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                sum += input[k];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; maxx) &#123;</span><br><span class="line">                    maxx = sum;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>用$S[i, j]$表示数组$A$从下标$i$到$j$的区间和。这个算法的无用功在于，当我们求$S[i, j]$时，每次都要指针$k$从$i$到$j$遍历求和一遍，这个过程的复杂度为$O(N)$。但$S[i, j] &#x3D; S[i, j - 1] + A[j]$，当$j - 1 &gt; i$时，$S[i,j - 1]$在上一次循环时已经求出来了，此处再进行从头遍历计算就造成了不必要的浪费。</p>
<p>所以如果能把区间求和操作从$O(N)$优化到$O(1)$，那么算法整体的复杂度就会从$O(N^3)$优化到$O(N^2)$。优化途径通常有两种。一种是使用前缀和，看是否保留原始信息决定是否要开辟额外空间。若要保留数组信息，空间复杂度由$O(1)$变为$O(N)$，但时间复杂度由$O(N^3)$降到$O(N^2)$，算是以空间换时间。另一种方法是不需要开额外的空间，由于求和过程具有连续性，只需使用上一次的计算结果用于本次计算，空间复杂度仍为$O(1)$，时间复杂度变为$O(N^2)$。</p>
<p>这就产生了以下两种时间复杂度为$O(N^2)$的二重循环方法。</p>
<h3 id="O-N-2-算法"><a href="#O-N-2-算法" class="headerlink" title="$O(N^2)$算法"></a>$O(N^2)$算法</h3><h4 id="最好和最坏情况都是-O-N-2-算法"><a href="#最好和最坏情况都是-O-N-2-算法" class="headerlink" title="最好和最坏情况都是$O(N^2)$算法"></a>最好和最坏情况都是$O(N^2)$算法</h4><p>这种方法就是把三重循环里的区间求和过程从$O(N)$优化到$O(1)$，有如下两种操作。</p>
<p><strong>前缀和优化</strong></p>
<p>前缀和可以在$O(1)$复杂度下，求出数组任意长度的区间总和。若不需要保留原始数组信息，可以直接用原来的数组空间求出前缀和；否则，需要额外开辟$N$个空间，用来记录前缀和。</p>
<p>C++实现如下：</p>
<ul>
<li>直接使用数组空间计算前缀和</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">op2_1_1</span><span class="params">(std::vector&lt;<span class="type">float</span>&gt;&amp; input)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接使用原来数组空间记录前缀和，原数组信息会被覆盖</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; input.<span class="built_in">size</span>(); ++i) </span><br><span class="line">        input[i] += input[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> maxx = input[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; input.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="comment">// 使用前缀和计算区间和，时间复杂度O(1)</span></span><br><span class="line">            <span class="keyword">auto</span> sum = input[j] - (i == <span class="number">0</span> ? <span class="number">0</span> : input[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; maxx) &#123;</span><br><span class="line">                maxx = sum;</span><br><span class="line">                left = i;</span><br><span class="line">                right = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>额外开辟$N$个空间记录前缀和</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">op2_1_2</span><span class="params">(std::vector&lt;<span class="type">float</span>&gt;&amp; input)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用额外数组记录前缀和，原数组信息不会被覆盖，空间复杂度O(N)</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">prefix_sum</span><span class="params">(input.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    prefix_sum[<span class="number">0</span>] = input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; input.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        prefix_sum[i] = prefix_sum[i - <span class="number">1</span>] + input[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> maxx = input[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; input.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="comment">// 使用前缀和计算区间和，时间复杂度O(1)</span></span><br><span class="line">            <span class="keyword">auto</span> sum = prefix_sum[j] - (i == <span class="number">0</span> ? <span class="number">0</span> : prefix_sum[i - <span class="number">1</span>]); </span><br><span class="line">            <span class="keyword">if</span> (sum &gt; maxx) &#123;</span><br><span class="line">                maxx = sum;</span><br><span class="line">                left = i;</span><br><span class="line">                right = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用前一次的计算结果进行优化</strong></p>
<p>由于二重循环计算区间和具有连续性，当计算$S[i, j]$时，因为$S[i, j] &#x3D; S[i, j - 1] + A[j]$，其中$S[i, j - 1]$刚好是上一次计算得到的区间$[i, j - 1]$的总和，可以直接拿来帮助本次计算，就无需从头进行遍历求和。在遍历区间右端点的过程中，由于变量$sum$已经保留了区间$[i, j - 1]$的计算结果，本次区间和的计算结果就是$sum + A[j]$。</p>
<p>C++实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">op2_2</span><span class="params">(std::vector&lt;<span class="type">float</span>&gt;&amp; input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> maxx = input[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; input.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            sum += input[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; maxx) &#123;</span><br><span class="line">                maxx = sum;</span><br><span class="line">                left = i;</span><br><span class="line">                right = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h6><p>二重循环的浪费主要在确立区间端点上。浪费在哪里可以通过挖掘遍历过程中的求和结果看出。当确立左端点$i&#x3D;0$时，$j&#x3D;0, 1, \cdots, 12$的区间和结果如下图所示（下图其实就是数组的前缀和）。</p>
<img src="../img/2024-12-31-11-54-04-image.png" title="" alt="" data-align="center">

<p>以下基于<strong>前缀和</strong>的思想进行分析。</p>
<p>首先进行定义：</p>
<p>$S[i, j]$表示数组$A$从下标$i$到下标$j$的元素之和，$i \leq j$。</p>
<p>当$i &#x3D; 0$时，$S[i, j] &#x3D; S[0, j]$；</p>
<p>当$i &gt; 0$时，$S[i, j] &#x3D; S[0, j] - S[0, i - 1]$。</p>
<p>可以看出当$j&#x3D;9$时，前向累积和已经达到最大。因此当$i \leq 9$时，$S[i, 9]$是最大的，此时令$j &gt; 9$，<strong>计算$S[i, j]$就是无谓的浪费</strong>。</p>
<p>证明如下：</p>
<p>$\because 当0 &lt; i \leq 9时，S[i, j] &#x3D; S[0, j] - S[0, i - 1]$</p>
<p>由于$S[0, 9] \geq S[0, j]， j &#x3D; 1, 2, \cdots, 12$</p>
<p>$\therefore S[i, j] \leq S[0, 9] - S[0, i - 1]$</p>
<p>同理可证$i &#x3D; 0$的情况。</p>
<h4 id="最好情况-O-N-，最坏情况-O-N-2-算法"><a href="#最好情况-O-N-，最坏情况-O-N-2-算法" class="headerlink" title="最好情况$O(N)$，最坏情况$O(N^2)$算法"></a>最好情况$O(N)$，最坏情况$O(N^2)$算法</h4><p>基于上述分析，当左端点$i \leq 9$时，确定了总和最大区间的右端点就是$j &#x3D; 9$，在该段区间上总和最大区间只能是$[i, 9]$。此时总和最大区间可能的位置被$j &#x3D; 9$劈成两部分，分为$[i, 9],(i \leq 9)$或者$[i, j], (i &gt; 9)$。</p>
<p>在$[i, 9]$的区间上，如何确定总和最大区间的左端点$i$呢？由公式$S[i, j] &#x3D; S[0, 9] - S[0, i - 1]$可知，当$S[0, i - 1]$最小时，$S[i, j]$最大。因此只要从右端点$j &#x3D; 9$开始向前遍历，找到前向累积和最小的位置$k &#x3D; 3$，则左端点$i &#x3D; k + 1 &#x3D; 4$。</p>
<p><strong>但是</strong>，这时只求出了局部的总和最大区间。即在区间$[0, 9]$上，确定了该区间上的总和最大区间为$[4, 9]$。但是区间$[4, 9]$是否为全局的总和最大区间需要进一步验证。另一个总和最大区间可能的位置在区间$[10, 12]$，因此还需要在该段区间上找出总和最大区间。最后比较找出的所有备选总和最大区间，哪一段的区间和最大，则该段区间为全局的总和最大区间。</p>
<p>如何在找出区间$[10, 12]$的总和最大区间？跟之前的方法一样，从位置$10$开始，向后找前向累计和最大的位置，该位置即为新的总和最大区间的右端点，再前向遍历找到左端点。此时区间$[10, 12]$仍可能被从$10$开始前向累计和最大的位置分成两部分，还需要在后一部分继续找可能的总和最大区间。最后就变成了一个不断减少搜索区间，一段一段找潜在总和最大区间的递归问题。最后比较所有备选区间的区间和，得出全局总和最大区间。</p>
<p>这种方式的时间复杂度是多少呢？最好情况是$O(N)$，最坏情况是$O(N^2)$。</p>
<p>首先分析最好情况。最好情况是数组的末端位置就是前向累计和最大的位置，只需反向遍历一遍确立左端点。此时共遍历两次序列，复杂度为$O(N)$。</p>
<p>再来分析最坏情况。因为每次要确立区间总和最大区间的右端点，都要让$j$从新区间开始的位置，一直遍历到数组的末端，才能找出最大值。举一个特殊的样例，$3, 10, -10, 8, -8, 7, -9, 6, -9, 5, -5, 4$，其前向累计和如下图所示。</p>
<img src="../img/2025-01-01-10-50-25-image.png" title="" alt="" data-align="center">

<p>可以看出，从第一个位置开始以两个数为一组，每组数中第一个数小于第二个数，第二个数是后边所有数的最大值。此时$j$平均要遍历$\lceil\frac{N}{2}\rceil$趟，平均每趟遍历长度为$\frac{N}{2} + 1$，总复杂度就为二者乘积，是$O(N^2)$。</p>
<p>C++实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正向遍历数组，记录前缀和，找到最大值，为右端点，然后反向遍历找到最小值，确立左端点。之后对下一段区间重复上述过程，最好情况时间复杂度O(N)，最坏情况时间复杂度O(N^2)</span></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">size_t</span>, <span class="type">size_t</span>&gt; <span class="title">op2_2</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; input)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!input.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="comment">// 求前缀和</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">prefix_sum</span><span class="params">(input.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了方便，下标从1开始，prefix_sum[0] = 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= input.<span class="built_in">size</span>(); ++i) prefix_sum[i] = prefix_sum[i - <span class="number">1</span>] + input[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 从头开始遍历，找到前缀和的最大值</span></span><br><span class="line">    <span class="keyword">auto</span> maxx = prefix_sum[<span class="number">1</span>];</span><br><span class="line">    <span class="type">size_t</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录最大值的位置</span></span><br><span class="line">    <span class="type">size_t</span> max_pos = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (max_pos &lt; prefix_sum.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> pre_pos = max_pos;</span><br><span class="line">        <span class="keyword">auto</span> cur_maxx = prefix_sum[max_pos + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = max_pos + <span class="number">1</span>; j &lt; prefix_sum.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prefix_sum[j] &gt;= cur_maxx) &#123;</span><br><span class="line">                cur_maxx = prefix_sum[j];</span><br><span class="line">                max_pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从最大值位置开始反向遍历，找到前缀和的最小值</span></span><br><span class="line">        <span class="keyword">auto</span> minn = prefix_sum[max_pos];</span><br><span class="line">        <span class="type">size_t</span> min_pos = max_pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = min_pos; i &gt;= pre_pos; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prefix_sum[i - <span class="number">1</span>] &lt; minn) &#123;</span><br><span class="line">                minn = prefix_sum[i - <span class="number">1</span>];</span><br><span class="line">                min_pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prefix_sum[max_pos] - prefix_sum[min_pos - <span class="number">1</span>] &gt; maxx) &#123;</span><br><span class="line">            maxx = prefix_sum[max_pos] - prefix_sum[min_pos - <span class="number">1</span>];</span><br><span class="line">            left = min_pos;</span><br><span class="line">            right = max_pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;left - <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h5><p>要分析这个算法的无用功做在什么地方，从最坏情况入手即可。比起最好情况，计算浪费在在确立剩余部分的总和最大区间时，每次要遍历剩余部分的最大值找到右端点，而最大值刚好呈递减的趋势。实际上继续遍历最大值位置之后的区间是一种浪费。仔细想一下，为什么最大值位置$j$之后的所有位置，其前向累计和都小于$S[i, j]$？</p>
<p>通过数学分析，上述表达即</p>
<p>$S[i, j] + S[j + 1, m] &lt; S[l, j]$，其中$j &lt; m \leq r$，$r$为整个序列的末端位置。</p>
<p>显然对$\forall m \in (j, r]$，均有$S[j + 1, m] &lt; 0$。</p>
<p>发现这个规律，可以进行<strong>逆向思考</strong>。与其找剩余部分的最大值，不如找剩余区间从哪里开始到序列末尾位置的区间和小于$0$（因为末端位置$r \in (j, r]$，而位置$r$能提供位计算便利上的优越性），就在哪里停止。数学表达即为当$S[0, r] - S[0, j + 1] &lt; 0$时，$j$即为所要找的剩余区间前向累计和最大值所在的位置。而之前算法里继续遍历$[j + 1, r]$中的所有位置就是一种计算上的浪费。</p>
<h3 id="O-N-算法"><a href="#O-N-算法" class="headerlink" title="$O(N)$算法"></a>$O(N)$算法</h3><p>这种方法就是延续上述分析，在遍历区间时，通过判断$S[0, r] - S[0, j + 1]$是否小于$0$，来确定$j$是否要停止向后遍历，节省了$O(N^2)$算法中每一次都要$j$遍历到数组末端位置的浪费。因此该算法最好和最坏情况下的时间复杂度都是$O(N)$，$j$从头开始正向遍历，$i$在每一段子区间从$j$开始进行反向遍历，总共的计算复杂度只有两趟遍历。</p>
<p>C++实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="type">size_t</span>, <span class="type">size_t</span>&gt; <span class="title">op3_1</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; input)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!input.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="type">size_t</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> maxx = input[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 计算前向累计和</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">prefix_sum</span><span class="params">(input.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= input.<span class="built_in">size</span>(); ++i) prefix_sum[i] = prefix_sum[i - <span class="number">1</span>] + input[i - <span class="number">1</span>];</span><br><span class="line">    <span class="type">size_t</span> pre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = pre; j &lt; prefix_sum.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix_sum[prefix_sum.<span class="built_in">size</span>() - <span class="number">1</span>] - prefix_sum[j + <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = j; i &gt;= pre; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prefix_sum[j] - prefix_sum[i - <span class="number">1</span>] &gt; maxx) &#123;</span><br><span class="line">                    maxx = prefix_sum[j] - prefix_sum[i - <span class="number">1</span>];</span><br><span class="line">                    left = i - <span class="number">1</span>;</span><br><span class="line">                    right = j - <span class="number">1</span>;  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法仍可以进行<strong>逆向思考</strong>。如果从位置$i$开始，到位置$j$时，有$S[i, j] &lt; 0$。可以认定区间$[i, j]$对位置$j$之后的区间不会有贡献。那么当前只需计算区间$[i, j]$的总和最大区间即可，该区间作为参与竞争全局总和最大区间的一个备选区间。这种情况下不会出现$\exists m \in (i, j]$，使得$S[m, j] &gt; 0$。因为$S[i, j] &#x3D; S[i, m - 1] + S[m, j]$，并且$S[i, j] &lt; 0$，$S[m, j] &gt; 0$，必然有$S[i, m - 1] &lt; 0$。因此在$m - 1$位置时，就已经计算$[i, m - 1]$里的总和最大区间了。之后从位置$j + 1$开始，同样进行上述操作。最终可能会得到多个备选区间，只需挑出备选区间中区间和最大的一个即可。也可以在选择时就进行排除，区间和小于当前已发现的最大区间和就进行丢弃。该算法即为书中提到的最优算法。</p>
<p>使用上述算法该如何确定区间$[i, j]$的总和最大区间呢？与之前的算法类似，从位置$i$开始，使得$S[i, m]$最大的位置$m$即为区间的右端点。跟之前分析的最大值的作用类似，是因为$S[m + 1, n] &lt; 0$，$m + 1 &lt; n \leq j$，即从位置$i$开始，前向累计和最大位置之后的区间均对前半部分没有贡献。而区间的左端点实际上就是$i$，因为假设存在一点$p \in (i, m]$，使得区$[i, j]$上的总和最大区间是$[p, m]$。而条件可以肯定的是对$\forall \lambda \in [i, j]$，均有$S[i, \lambda] \geq 0$，所以$S[i, p - 1] \geq 0$。因为$S[i, m] &#x3D; S[i, p - 1] + S[p, m]$，必然存在$[i, m]$的区间和大于$[p, m]$的区间和，假设不成立。所以区间$[i, j]$上的总和最大区间的左端点为$i$，右端点即为从位置$i$开始前向累计和最大的位置。</p>
<p>C++实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="type">size_t</span>, <span class="type">size_t</span>&gt; <span class="title">op3_2</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; input)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!input.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="type">size_t</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> maxx = input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">auto</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; input.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        sum += input[j];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; maxx) &#123;</span><br><span class="line">            maxx = sum;</span><br><span class="line">            right = j;</span><br><span class="line">            left = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            pre = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法只需一趟正向遍历。最好和最坏情况均为$O(N)$，空间复杂度为$O(1)$。而之前的算法中，凡是需要用到前缀和的，在不破坏原有输入的情况下，均需要$O(N)$的空间复杂度。</p>
<p>根据估算，求序列总和最大区间，至少需要遍历一趟序列，因此$O(N)$复杂度已是求解该问题的复杂度上限，已无优化的可能。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>经过上述分析，可以得出拿到一个问题时进行有效分析的步骤：</p>
<ol>
<li><p>对问题计算复杂度的边界有大概的认识。以本文例题为例，求序列总和最大区间，至少要遍历一趟序列，因此复杂度的上限就是$O(N)$。而当我们想出一种求解问题的可行算法时，如果是$O(N^2)$或者$O(N^3)$的算法，基于对问题计算复杂度边界的认识，我们可以知道算法仍有可以优化的空间。</p>
</li>
<li><p>优化一个算法，最常用的方法是检查算法里是否存在计算上的无用功。比如本文的分析中，$O(N^3)$算法中计算区间和需要从头到尾遍历是在做无用功，$O(N^2)$算法中确定区间左右端点时做了大量无用功。借助数学工具和逻辑推理，将逻辑思考通过数学语言表达，并且能够将一个命题转化为另一个相对容易的等价命题，能够有效检查出计算上的无用功。</p>
</li>
<li><p>分析问题时，逆向思考或许会带来意想不到的惊喜。很多时候正向思考遇到麻烦或者步骤繁琐，逆向思考或许能迎刃而解。</p>
</li>
</ol>
<h2 id="附录-对书中-O-N-log-N-算法的优化"><a href="#附录-对书中-O-N-log-N-算法的优化" class="headerlink" title="附录 对书中$O(N\log N)$算法的优化"></a>附录 对书中$O(N\log N)$算法的优化</h2><p>书中讲到的$O(N \log N)$算法是基于分治的思想，将一个大区间分为两段子区间，然后求子区间的总和最大区间。此时整个序列的总和最大区间所在的位置可能有三种情况。具体步骤本文不多赘述，书里讲的比较详细。下边给出该算法的代码实现。</p>
<p>C++实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="type">size_t</span>, <span class="type">size_t</span>&gt; <span class="title">op4_1</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; input, <span class="type">size_t</span> left, <span class="type">size_t</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!input.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">    <span class="keyword">auto</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> left_pair = <span class="built_in">op4_1</span>(input, left, mid);</span><br><span class="line">    <span class="keyword">auto</span> right_pair = <span class="built_in">op4_1</span>(input, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">auto</span> left_l = left_pair.first, left_r = left_pair.second;</span><br><span class="line">    <span class="keyword">auto</span> right_l = right_pair.first, right_r = right_pair.second;</span><br><span class="line">    <span class="type">float</span> left_sum = <span class="number">0</span>, right_sum = <span class="number">0</span>, cross_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = left_l; i &lt;= left_r; ++i) left_sum += input[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = right_l; i &lt;= right_r; ++i) right_sum += input[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = left_l; i &lt;= right_r; ++i) cross_sum += input[i];</span><br><span class="line">    <span class="keyword">if</span> (left_r == mid &amp;&amp; right_l == mid + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (left_sum &gt; <span class="number">0</span> &amp;&amp; right_sum &gt; <span class="number">0</span>) <span class="keyword">return</span> &#123;left_l, right_r&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left_sum &gt; right_sum) <span class="keyword">return</span> &#123;left_l, left_r&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> &#123;right_l, right_r&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left_sum &gt; right_sum &amp;&amp; left_sum &gt; cross_sum) <span class="keyword">return</span> &#123;left_l, left_r&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (right_sum &gt; left_sum &amp;&amp; right_sum &gt; cross_sum) <span class="keyword">return</span> &#123;right_l, right_r&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> &#123;left_l, right_r&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>这个算法对于$O(N^3)$算法的优化在于，将确定区间左右端点从$O(N^2)$降到$O(\log N)$，但求区间和时仍然使用遍历求和的方式。根据之前的优化策略，求区间和可以使用前缀和数组在$O(1)$复杂度计算出结果。因此优化后的整个算法，首先求前缀和数组需要一趟遍历，复杂度为$O(N)$；之后使用分治算法确定区间左右端点的复杂度为$O(\log N)$。因此整体的复杂度为$O(N)$。</p>
<p>优化后的C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::pair&lt;<span class="type">size_t</span>, <span class="type">size_t</span>&gt; _op4_2(<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; input, <span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; prefix_sum, <span class="type">size_t</span> left, <span class="type">size_t</span> right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">    <span class="keyword">auto</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> left_pair = _op4_2(input, prefix_sum, left, mid);</span><br><span class="line">    <span class="keyword">auto</span> right_pair = _op4_2(input, prefix_sum, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">auto</span> left_l = left_pair.first, left_r = left_pair.second;</span><br><span class="line">    <span class="keyword">auto</span> right_l = right_pair.first, right_r = right_pair.second;</span><br><span class="line">    <span class="keyword">auto</span> left_sum = prefix_sum[left_r + <span class="number">1</span>] - prefix_sum[left_l];</span><br><span class="line">    <span class="keyword">auto</span> right_sum = prefix_sum[right_r + <span class="number">1</span>] - prefix_sum[right_l];</span><br><span class="line">    <span class="keyword">auto</span> cross_sum = prefix_sum[right_r + <span class="number">1</span>] - prefix_sum[left_l];</span><br><span class="line">    <span class="keyword">if</span> (left_sum &gt; right_sum &amp;&amp; left_sum &gt; cross_sum) <span class="keyword">return</span> &#123;left_l, left_r&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (right_sum &gt; left_sum &amp;&amp; right_sum &gt; cross_sum) <span class="keyword">return</span> &#123;right_l, right_r&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> &#123;left_l, right_r&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">size_t</span>, <span class="type">size_t</span>&gt; <span class="title">op4_2</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; input)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!input.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="comment">// 计算前缀和</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">prefix_sum</span><span class="params">(input.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= input.<span class="built_in">size</span>(); ++i) prefix_sum[i] = prefix_sum[i - <span class="number">1</span>] + input[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> _op4_2(input, prefix_sum, <span class="number">0</span>, input.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，为了体会算法复杂度的巨大差异，在万级的数据规模上测试各个算法的执行用时。</p>
<p>当数据量为$10, 000$时，各算法的执行时间如下：</p>
<img src="../img/2025-01-08-22-49-32-image.png" title="" alt="" data-align="center">

<p>在数据量为$100, 000$时，除了三重循环算法，各算法的执行时间如下：</p>
<img src="../img/2025-01-08-22-51-47-image.png" title="" alt="" data-align="center">
]]></content>
  </entry>
</search>
